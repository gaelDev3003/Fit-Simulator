import {
  GoogleGenerativeAI,
  GenerativeModel,
  Part,
} from '@google/generative-ai';
import sharp from 'sharp';
import { PerformanceMonitor, createPerformanceMonitor } from './performance';

export interface GeminiImageGenerationRequest {
  personPath: string;
  itemPaths: string[];
  user_id: string;
  user_token: string;
}

export interface GeminiImageGenerationResponse {
  success: boolean;
  imageBuffer?: Buffer;
  imageUrl?: string;
  error?: string;
  duration_ms?: number;
}

export interface ImageAsset {
  path: string;
  buffer: Buffer;
  mimeType: string;
}

export class GeminiClient {
  private model: GenerativeModel;
  private isLive: boolean;
  private performanceMonitor: PerformanceMonitor;

  constructor() {
    const apiKey = process.env.GEMINI_API_KEY;
    this.isLive = process.env.GEMINI_LIVE === 'true';

    if (this.isLive && !apiKey) {
      throw new Error('GEMINI_API_KEY is required when GEMINI_LIVE=true');
    }

    if (this.isLive) {
      const genAI = new GoogleGenerativeAI(apiKey!);
      this.model = genAI.getGenerativeModel({
        model: 'gemini-2.5-flash-image-preview',
        generationConfig: {
          temperature: 0.7,
          topK: 40,
          topP: 0.95,
          maxOutputTokens: 1024,
        },
      });
    } else {
      // Stub mode - no actual model needed
      this.model = null as any;
    }

    // Initialize performance monitor with custom config
    this.performanceMonitor = createPerformanceMonitor({
      maxDurationMs: parseInt(process.env.GEMINI_REQUEST_TIMEOUT_MS || '90000'),
      retryAttempts: 2,
      retryDelayMs: 2000,
      timeoutMs: parseInt(process.env.GEMINI_REQUEST_TIMEOUT_MS || '60000'),
    });
  }

  /**
   * Generate image using Gemini API with performance monitoring
   */
  async generateImage(
    request: GeminiImageGenerationRequest
  ): Promise<GeminiImageGenerationResponse> {
    this.performanceMonitor.start();

    try {
      if (!this.isLive) {
        return this.generateStubResponse();
      }

      // Load and prepare image assets (outside performance monitoring)
      const personAsset = await this.loadImageAsset(
        request.personPath,
        request.user_id,
        request.user_token
      );
      const itemAssets = await Promise.all(
        request.itemPaths.map((path) =>
          this.loadImageAsset(path, request.user_id, request.user_token)
        )
      );

      // Construct prompt (outside performance monitoring)
      const prompt = this.constructPrompt(request, personAsset, itemAssets);

      // Prepare content parts
      const parts: Part[] = [
        { text: prompt },
        {
          inlineData: {
            mimeType: personAsset.mimeType,
            data: personAsset.buffer.toString('base64'),
          },
        },
      ];

      // Add item images
      for (const itemAsset of itemAssets) {
        parts.push({
          inlineData: {
            mimeType: itemAsset.mimeType,
            data: itemAsset.buffer.toString('base64'),
          },
        });
      }

      // Execute Gemini API call with performance monitoring and retries
      const result = await this.performanceMonitor.executeWithRetry(
        async () => {
          // Add AbortController for timeout
          const controller = new AbortController();
          const timeoutMs = parseInt(
            process.env.GEMINI_REQUEST_TIMEOUT_MS || '60000'
          );
          const timeoutId = setTimeout(
            () => controller.abort('timeout'),
            timeoutMs
          );

          try {
            const result = await this.model.generateContent({
              contents: [{ role: 'user', parts }],
            });
            clearTimeout(timeoutId);
            return result;
          } catch (error) {
            clearTimeout(timeoutId);
            throw error;
          }
        }
      );

      const response = await result.response;
      const responseParts = response.candidates?.[0]?.content?.parts || [];
      const imageParts = responseParts.filter(
        (part) =>
          part.inlineData && part.inlineData.mimeType?.startsWith('image/')
      );

      console.log(
        `[Gemini] Model: gemini-2.5-flash-image-preview, Parts found: ${responseParts.length}, Image parts: ${imageParts.length}`
      );

      const imagePart = imageParts[0];

      if (!imagePart?.inlineData) {
        throw new Error(
          'No image generated by Gemini API - no valid image part found'
        );
      }

      // Decode base64 image
      const imageBuffer = Buffer.from(imagePart.inlineData.data, 'base64');

      // Validate and process image
      const processedBuffer = await this.validateAndProcessImage(imageBuffer);

      const duration = this.performanceMonitor.getElapsedMs();

      return {
        success: true,
        imageBuffer: processedBuffer,
        duration_ms: duration,
      };
    } catch (error) {
      console.error('Gemini API error:', error);
      throw error;
    }
  }

  /**
   * Generate stub response for development/testing
   */
  private async generateStubResponse(): Promise<GeminiImageGenerationResponse> {
    // Simulate processing time (1-3 seconds)
    await new Promise((resolve) =>
      setTimeout(resolve, 1000 + Math.random() * 2000)
    );

    const duration = this.performanceMonitor.getElapsedMs();

    // Create a simple placeholder image
    const placeholderBuffer = await sharp({
      create: {
        width: 768,
        height: 768,
        channels: 3,
        background: { r: 200, g: 200, b: 200 },
      },
    })
      .png()
      .toBuffer();

    return {
      success: true,
      imageBuffer: placeholderBuffer,
      duration_ms: duration,
    };
  }

  /**
   * Load image asset from Supabase Storage
   */
  private async loadImageAsset(
    path: string,
    userId: string,
    userToken: string
  ): Promise<ImageAsset> {
    // Normalize and validate path
    const safePath = this.assertUserScopedPath(path, userId);

    const { createClient } = await import('@supabase/supabase-js');

    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

    const supabase = createClient(supabaseUrl, supabaseAnonKey, {
      db: { schema: 'fit' },
      global: {
        headers: {
          Authorization: `Bearer ${userToken}`,
        },
      },
    });

    // Download image from storage
    const { data, error } = await supabase.storage
      .from('fit-originals')
      .download(safePath);

    if (error || !data) {
      throw new Error(
        `Failed to load image from ${path}: ${error?.message || 'No data'}`
      );
    }

    // Convert blob to buffer
    const buffer = Buffer.from(await data.arrayBuffer());

    // Determine MIME type
    const mimeType = this.getMimeTypeFromBuffer(buffer);

    return {
      path,
      buffer,
      mimeType,
    };
  }

  /**
   * Construct prompt for image generation
   */
  private constructPrompt(
    request: GeminiImageGenerationRequest,
    personAsset: ImageAsset,
    itemAssets: ImageAsset[]
  ): string {
    const itemDescriptions = itemAssets
      .map((_, index) => `item ${index + 1}`)
      .join(', ');

    let prompt = `Create a high-quality fashion simulation image showing a person wearing ${itemDescriptions}. `;
    prompt += `The person should be in a natural, neutral pose. `;

    prompt += `The image should be 768x768 pixels, professional quality, with good lighting and composition. `;
    prompt += `Make sure the clothing items fit naturally on the person and the overall look is stylish and realistic. `;
    prompt += `Include a subtle watermark in the bottom right corner.`;

    return prompt;
  }

  /**
   * Validate and process generated image
   * Converts to WebP format with longest side 768px as per Phase 4 requirements
   */
  private async validateAndProcessImage(imageBuffer: Buffer): Promise<Buffer> {
    try {
      // Get image metadata to determine current dimensions
      const metadata = await sharp(imageBuffer).metadata();
      const { width = 0, height = 0 } = metadata;

      // Calculate resize dimensions to ensure longest side is 768px
      let resizeWidth: number;
      let resizeHeight: number;

      if (width > height) {
        // Landscape: width is longest side
        resizeWidth = 768;
        resizeHeight = Math.round((height * 768) / width);
      } else {
        // Portrait or square: height is longest side
        resizeHeight = 768;
        resizeWidth = Math.round((width * 768) / height);
      }

      // Process with sharp to ensure proper format and size
      const processedBuffer = await sharp(imageBuffer)
        .resize(resizeWidth, resizeHeight, {
          fit: 'inside', // Maintain aspect ratio, ensure longest side is 768
          withoutEnlargement: true, // Don't enlarge smaller images
        })
        .webp({
          quality: 90,
          effort: 6,
        })
        .toBuffer();

      return processedBuffer;
    } catch (error) {
      console.error('Image processing error:', error);
      throw new Error('Failed to process generated image');
    }
  }

  /**
   * Assert and normalize user-scoped storage path
   */
  private assertUserScopedPath(path: string, userId: string): string {
    // Remove leading slash if present
    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;

    // Ensure path starts with user ID
    if (!normalizedPath.startsWith(`${userId}/`)) {
      throw new Error(
        `Invalid storage path: ${path} - must be scoped to user ${userId}`
      );
    }

    return normalizedPath;
  }

  /**
   * Get MIME type from buffer
   */
  private getMimeTypeFromBuffer(buffer: Buffer): string {
    // Check file signatures
    if (buffer[0] === 0xff && buffer[1] === 0xd8) {
      return 'image/jpeg';
    }
    if (
      buffer[0] === 0x89 &&
      buffer[1] === 0x50 &&
      buffer[2] === 0x4e &&
      buffer[3] === 0x47
    ) {
      return 'image/png';
    }
    if (buffer[0] === 0x47 && buffer[1] === 0x49 && buffer[2] === 0x46) {
      return 'image/gif';
    }
    if (
      buffer[0] === 0x52 &&
      buffer[1] === 0x49 &&
      buffer[2] === 0x46 &&
      buffer[3] === 0x46
    ) {
      return 'image/webp';
    }

    // Default to JPEG
    return 'image/jpeg';
  }

  /**
   * Check if client is in live mode
   */
  get isLiveMode(): boolean {
    return this.isLive;
  }
}

// Export singleton instance
export const geminiClient = new GeminiClient();
